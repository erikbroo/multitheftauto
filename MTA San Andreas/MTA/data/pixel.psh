struct PS_INPUT
{
    float4 Position   : POSITION;
    float2 Texture    : TEXCOORD0;
};

struct PS_INPUT_LIGHTING
{
    float4 Position   : POSITION;
//    float4 Color      : COLOR0;
    float2 Texture    : TEXCOORD0;
    float3 Normal     : TEXCOORD1;
    float3 Position3D : TEXCOORD2;
};


struct PS_OUTPUT
{
    float4 Color   : COLOR0;
};


// Texture samplers
sampler2D TextureVideo;
sampler2D TextureMask;

sampler2D Texture;

float Alpha;

//////////////////////////////////////////////////////////////////////////////
// Mask shader
//////////////////////////////////////////////////////////////////////////////
PS_OUTPUT ps_mask( in PS_INPUT In )
{
    PS_OUTPUT Out;
    
    float4 mask = tex2D(TextureMask, In.Texture);
    float4 tex = tex2D(TextureVideo, In.Texture);
    
    //Out.Color = mask * tex;

    // Green channel determines the mask
    // Red channel determines the override
    //Out.Color = mask.g * tex * (1-mask.b) + float4(mask.r,mask.r,mask.r,mask.r);
    Out.Color = mask.g * tex + float4(mask.r,mask.r,mask.r,mask.r);
    
    Out.Color.rgba *= Alpha;

    return Out;
}

//////////////////////////////////////////////////////////////////////////////
// Per-pixel lighting shader
//////////////////////////////////////////////////////////////////////////////
float4 LightPosA;
float4 LightPosB;
float4 LightPosC;
float4 LightPosD;

float LightPowerA;
float LightPowerB;
float LightPowerC;
float LightPowerD;

float LightRadA;
float LightRadB;
float LightRadC;
float LightRadD;

float LightHack;

float DotProduct(float4 LightPos, float3 Pos3D, float3 Normal)
{
    float3 LightDir = normalize(LightPos - Pos3D);
    return dot(LightDir, Normal);
}

PS_OUTPUT ps_lighting( in PS_INPUT_LIGHTING In )
{
    PS_OUTPUT Out;
    
    float diffuseA = DotProduct ( LightPosA, In.Position3D, In.Normal ) * (LightRadA/length(In.Position3D - LightPosA));
    float diffuseB = DotProduct ( LightPosB, In.Position3D, In.Normal ) * (LightRadB/length(In.Position3D - LightPosB));
    float diffuseC = DotProduct ( LightPosC, In.Position3D, In.Normal ) * (LightRadC/length(In.Position3D - LightPosC));
    float diffuseD = DotProduct ( LightPosD, In.Position3D, In.Normal ) * (LightRadD/length(In.Position3D - LightPosD));

//	float3 origcolor = tex2D(Texture, In.Texture) * In.Color;
	float3 origcolor = tex2D(Texture, In.Texture);
	float diffuse = (diffuseA*LightPowerA)+(diffuseB*LightPowerB)+(diffuseC*LightPowerC)+(diffuseD*LightPowerD);
    float3 color = origcolor*clamp(diffuse+LightHack,0.0,1.0);
    
    Out.Color = float4(color.rgb, 1);
    
    Out.Color.rgb *= Alpha;

    return Out;
}

//////////////////////////////////////////////////////////////////////////////
// Bloom and blur shader
//////////////////////////////////////////////////////////////////////////////
//Alpha value
float alpha;

// Pixel width in texels
float pixelWidth = 2.0;

float PixelKernel[13] =
{
    -6,
    -5,
    -4,
    -3,
    -2,
    -1,
     0,
     1,
     2,
     3,
     4,
     5,
     6,
};

static const float BlurWeights[13] = 
{
    0.002216,
    0.008764,
    0.026995,
    0.064759,
    0.120985,
    0.176033,
    0.199471,
    0.176033,
    0.120985,
    0.064759,
    0.026995,
    0.008764,
    0.002216,
};

PS_OUTPUT ps_bloom( in PS_INPUT In )
{
	PS_OUTPUT Out;

    // Apply surrounding pixels
    float4 sum = 0;
    float2 samp = In.Texture;

    for (int i = 0; i < 13; i++) {
        samp.x = In.Texture.x + PixelKernel[i] * pixelWidth;
        sum += tex2D(Texture, samp.xy) * BlurWeights[i];
    }
    sum.a = alpha;
    
    Out.Color = sum;
        
    return Out;
}
